# Action: Validador de Sistema de Arquivos
# Previne, detecta e corrige erros de arquivos n√£o encontrados

name: "file_system_validator"
description: "Valida e recupera integridade do sistema de arquivos com preven√ß√£o proativa"
version: "1.0"
author: "Killo Framework"

parameters:
  - name: "target_path"
    type: "string"
    required: true
    description: "Caminho do arquivo ou diret√≥rio a ser validado"
    
  - name: "operation_type"
    type: "choice"
    options: ["read", "write", "create", "delete", "move", "copy"]
    default: "read"
    description: "Tipo de opera√ß√£o planejada"
    
  - name: "validation_level"
    type: "choice"
    options: ["basic", "comprehensive", "deep"]
    default: "comprehensive"
    description: "N√≠vel de valida√ß√£o a ser aplicada"
    
  - name: "auto_recovery"
    type: "boolean"
    default: true
    description: "Habilitar recupera√ß√£o autom√°tica de erros"

execution:
  mode: "hybrid"
  timeout: 120000  # 2 minutos para valida√ß√£o completa

steps:
  - name: "normalize_and_validate_path"
    run: |
      # Normalizar e validar o caminho fornecido
      echo "üîç Normalizando e validando caminho: $target_path"
      
      # Normalizar caminho (remover ../, ./, etc.)
      normalized_path=$(realpath -m "$target_path" 2>/dev/null || echo "$target_path")
      echo "Caminho normalizado: $normalized_path"
      
      # Validar formato do caminho
      if [[ ! "$normalized_path" =~ ^/ ]]; then
        echo "‚ùå Caminho inv√°lido: deve ser absoluto"
        exit 1
      fi
      
      # Verificar caracteres perigosos
      if [[ "$normalized_path" =~ [\;\&\|\$\`\>\<\(\)\{\}] ]]; then
        echo "‚ùå Caminho cont√©m caracteres perigosos"
        exit 1
      fi
      
      echo "NORMALIZED_PATH=$normalized_path" >> $GITHUB_ENV
      
      # Extrair informa√ß√µes do caminho
      dir_path=$(dirname "$normalized_path")
      file_name=$(basename "$normalized_path")
      file_ext="${file_name##*.}"
      
      echo "DIR_PATH=$dir_path" >> $GITHUB_ENV
      echo "FILE_NAME=$file_name" >> $GITHUB_ENV
      echo "FILE_EXT=$file_ext" >> $GITHUB_ENV

  - name: "check_prerequisites"
    run: |
      # Verificar pr√©-requisitos para a opera√ß√£o
      echo "üîç Verificando pr√©-requisitos para opera√ß√£o: $operation_type"
      
      # Verificar se o diret√≥rio pai existe
      if [ ! -d "$DIR_PATH" ]; then
        echo "‚ö†Ô∏è Diret√≥rio pai n√£o existe: $DIR_PATH"
        
        if [ "$auto_recovery" = "true" ]; then
          echo "üõ†Ô∏è Criando diret√≥rio pai (recupera√ß√£o autom√°tica)..."
          mkdir -p "$DIR_PATH"
          echo "‚úÖ Diret√≥rio pai criado: $DIR_PATH"
        else
          echo "‚ùå Diret√≥rio pai n√£o existe e recupera√ß√£o autom√°tica desabilitada"
          exit 1
        fi
      fi
      
      # Verificar permiss√µes do diret√≥rio pai
      if [ ! -r "$DIR_PATH" ]; then
        echo "‚ùå Sem permiss√£o de leitura no diret√≥rio: $DIR_PATH"
        exit 1
      fi
      
      if [ "$operation_type" = "write" ] || [ "$operation_type" = "create" ] || [ "$operation_type" = "move" ] || [ "$operation_type" = "copy" ]; then
        if [ ! -w "$DIR_PATH" ]; then
          echo "‚ùå Sem permiss√£o de escrita no diret√≥rio: $DIR_PATH"
          exit 1
        fi
      fi
      
      # Verificar espa√ßo em disco
      available_space=$(df -k "$DIR_PATH" | awk 'NR==2 {print $4}')
      if [ "$available_space" -lt 10240 ]; then  # Menos de 10MB
        echo "‚ö†Ô∏è Espa√ßo em disco insuficiente: ${available_space}KB dispon√≠veis"
        
        if [ "$auto_recovery" = "true" ]; then
          echo "üõ†Ô∏è Tentando liberar espa√ßo..."
          # Limpar arquivos tempor√°rios
          find /tmp -name "killo_*" -type f -delete 2>/dev/null || true
          echo "‚úÖ Espa√ßo liberado"
        else
          echo "‚ùå Espa√ßo insuficiente e recupera√ß√£o autom√°tica desabilitada"
          exit 1
        fi
      fi
      
      echo "‚úÖ Pr√©-requisitos verificados com sucesso"

  - name: "validate_file_existence"
    run: |
      # Validar exist√™ncia do arquivo (para opera√ß√µes de leitura)
      echo "üîç Validando exist√™ncia do arquivo..."
      
      if [ "$operation_type" = "read" ]; then
        if [ ! -f "$NORMALIZED_PATH" ]; then
          echo "‚ùå Arquivo n√£o encontrado: $NORMALIZED_PATH"
          
          if [ "$auto_recovery" = "true" ]; then
            echo "üõ†Ô∏è Iniciando recupera√ß√£o autom√°tica do arquivo..."
            
            # Estrat√©gias de recupera√ß√£o
            recovery_strategies=(
              "search_similar"
              "check_backup"
              "recreate_from_template"
              "search_standard_locations"
            )
            
            for strategy in "${recovery_strategies[@]}"; do
              echo "üîÑ Tentando estrat√©gia: $strategy"
              
              case "$strategy" in
                "search_similar")
                  # Buscar arquivos com nomes similares
                  similar_files=$(find "$DIR_PATH" -name "*${FILE_NAME%.*}*" -type f 2>/dev/null | head -5)
                  if [ -n "$similar_files" ]; then
                    echo "‚úÖ Arquivos similares encontrados:"
                    echo "$similar_files"
                    # Usar o primeiro arquivo similar
                    recovered_file=$(echo "$similar_files" | head -1)
                    echo "üìÅ Usando arquivo similar: $recovered_file"
                    cp "$recovered_file" "$NORMALIZED_PATH"
                    echo "‚úÖ Arquivo recuperado com sucesso"
                    break
                  fi
                  ;;
                  
                "check_backup")
                  # Verificar backups
                  backup_locations=(
                    "${NORMALIZED_PATH}.backup"
                    "${NORMALIZED_PATH}.bak"
                    "${NORMALIZED_PATH}~"
                    "${DIR_PATH}/.backup/${FILE_NAME}"
                  )
                  
                  for backup in "${backup_locations[@]}"; do
                    if [ -f "$backup" ]; then
                      echo "üìÅ Backup encontrado: $backup"
                      cp "$backup" "$NORMALIZED_PATH"
                      echo "‚úÖ Arquivo restaurado do backup"
                      break 2
                    fi
                  done
                  ;;
                  
                "recreate_from_template")
                  # Recriar a partir de template
                  template_locations=(
                    ".killo-workspace/templates/${FILE_EXT}.template"
                    ".killo-workspace/templates/${FILE_NAME}.template"
                    "/usr/share/killo/templates/${FILE_EXT}.template"
                  )
                  
                  for template in "${template_locations[@]}"; do
                    if [ -f "$template" ]; then
                      echo "üìÅ Template encontrado: $template"
                      cp "$template" "$NORMALIZED_PATH"
                      echo "‚úÖ Arquivo recriado a partir do template"
                      break 2
                    fi
                  done
                  ;;
                  
                "search_standard_locations")
                  # Buscar em locais padr√£o
                  standard_locations=(
                    "$DIR_PATH/${FILE_NAME}"
                    "${DIR_PATH}/$(basename ${FILE_NAME%.*}).${FILE_EXT}"
                    "${DIR_PATH}/default.${FILE_EXT}"
                    "${DIR_PATH}/index.${FILE_EXT}"
                  )
                  
                  for location in "${standard_locations[@]}"; do
                    if [ -f "$location" ] && [ "$location" != "$NORMALIZED_PATH" ]; then
                      echo "üìÅ Arquivo encontrado em local padr√£o: $location"
                      cp "$location" "$NORMALIZED_PATH"
                      echo "‚úÖ Arquivo copiado de local padr√£o"
                      break 2
                    fi
                  done
                  ;;
              esac
            done
            
            # Verificar se a recupera√ß√£o foi bem-sucedida
            if [ ! -f "$NORMALIZED_PATH" ]; then
              echo "‚ùå Todas as estrat√©gias de recupera√ß√£o falharam"
              echo "üìã Criando arquivo vazio como √∫ltimo recurso"
              touch "$NORMALIZED_PATH"
              echo "‚ö†Ô∏è Arquivo vazio criado - requer conte√∫do manual"
            fi
          else
            echo "‚ùå Arquivo n√£o encontrado e recupera√ß√£o autom√°tica desabilitada"
            exit 1
          fi
        else
          echo "‚úÖ Arquivo encontrado: $NORMALIZED_PATH"
        fi
      elif [ "$operation_type" = "create" ]; then
        if [ -f "$NORMALIZED_PATH" ]; then
          echo "‚ö†Ô∏è Arquivo j√° existe: $NORMALIZED_PATH"
          
          if [ "$auto_recovery" = "true" ]; then
            echo "üõ†Ô∏è Criando backup do arquivo existente..."
            timestamp=$(date +%Y%m%d_%H%M%S)
            backup_path="${NORMALIZED_PATH}.backup_${timestamp}"
            cp "$NORMALIZED_PATH" "$backup_path"
            echo "‚úÖ Backup criado: $backup_path"
          fi
        fi
      fi

  - name: "validate_file_integrity"
    run: |
      # Validar integridade do arquivo (se existir)
      echo "üîç Validando integridade do arquivo..."
      
      if [ -f "$NORMALIZED_PATH" ]; then
        # Verificar tamanho do arquivo
        file_size=$(stat -c%s "$NORMALIZED_PATH" 2>/dev/null || echo "0")
        echo "üìä Tamanho do arquivo: $file_size bytes"
        
        # Verificar se o arquivo √© leg√≠vel
        if [ ! -r "$NORMALIZED_PATH" ]; then
          echo "‚ùå Arquivo n√£o √© leg√≠vel"
          
          if [ "$auto_recovery" = "true" ]; then
            echo "üõ†Ô∏è Tentando corrigir permiss√µes..."
            chmod 644 "$NORMALIZED_PATH"
            echo "‚úÖ Permiss√µes corrigidas"
          else
            exit 1
          fi
        fi
        
        # Verificar integridade b√°sica (para arquivos de texto)
        if file "$NORMALIZED_PATH" | grep -q "text"; then
          # Verificar se o arquivo n√£o est√° corrompido
          if [ -s "$NORMALIZED_PATH" ]; then
            # Tentar ler o arquivo
            if ! head -n 1 "$NORMALIZED_PATH" >/dev/null 2>&1; then
              echo "‚ùå Arquivo de texto parece estar corrompido"
              
              if [ "$auto_recovery" = "true" ]; then
                echo "üõ†Ô∏è Tentando recuperar arquivo corrompido..."
                
                # Criar backup do arquivo corrompido
                timestamp=$(date +%Y%m%d_%H%M%S)
                corrupted_backup="${NORMALIZED_PATH}.corrupted_${timestamp}"
                mv "$NORMALIZED_PATH" "$corrupted_backup"
                echo "üìÅ Arquivo corrompido movido para: $corrupted_backup"
                
                # Tentar recuperar conte√∫do
                if command -v strings &> /dev/null; then
                  strings "$corrupted_backup" > "$NORMALIZED_PATH" 2>/dev/null
                  echo "‚úÖ Conte√∫do parcialmente recuperado usando strings"
                else
                  # Criar arquivo vazio
                  touch "$NORMALIZED_PATH"
                  echo "‚ö†Ô∏è Arquivo vazio criado - conte√∫do perdido"
                fi
              else
                exit 1
              fi
            fi
          fi
        fi
        
        # Verificar permiss√µes adequadas para a opera√ß√£o
        case "$operation_type" in
          "write"|"create"|"delete"|"move"|"copy")
            if [ ! -w "$NORMALIZED_PATH" ]; then
              echo "‚ùå Sem permiss√£o de escrita no arquivo"
              
              if [ "$auto_recovery" = "true" ]; then
                echo "üõ†Ô∏è Corrigindo permiss√µes de escrita..."
                chmod 644 "$NORMALIZED_PATH"
                echo "‚úÖ Permiss√µes de escrita corrigidas"
              else
                exit 1
              fi
            fi
            ;;
        esac
        
        echo "‚úÖ Integridade do arquivo validada"
      fi

  - name: "perform_comprehensive_validation"
    run: |
      # Realizar valida√ß√£o abrangente baseada no n√≠vel
      echo "üîç Realizando valida√ß√£o abrangente (n√≠vel: $validation_level)..."
      
      case "$validation_level" in
        "basic")
          # Valida√ß√£o b√°sica
          echo "üìã Valida√ß√£o b√°sica:"
          echo "‚úÖ Caminho normalizado"
          echo "‚úÖ Pr√©-requisitos verificados"
          echo "‚úÖ Exist√™ncia validada"
          echo "‚úÖ Integridade b√°sica verificada"
          ;;
          
        "comprehensive")
          # Valida√ß√£o abrangente
          echo "üìã Valida√ß√£o abrangente:"
          
          # Verificar estrutura de diret√≥rios
          echo "üîç Verificando estrutura de diret√≥rios..."
          dir_structure=$(find "$DIR_PATH" -type d -name "*.d" 2>/dev/null | wc -l)
          echo "üìÅ Diret√≥rios encontrados: $dir_structure"
          
          # Verificar arquivos relacionados
          echo "üîç Verificando arquivos relacionados..."
          related_files=$(find "$DIR_PATH" -name "*${FILE_NAME%.*}*" -type f 2>/dev/null | wc -l)
          echo "üìÑ Arquivos relacionados: $related_files"
          
          # Verificar padr√µes de nomenclatura
          echo "üîç Validando padr√µes de nomenclatura..."
          if [[ "$FILE_NAME" =~ ^[a-zA-Z0-9_-]+\.[a-zA-Z0-9]+$ ]]; then
            echo "‚úÖ Nome de arquivo v√°lido"
          else
            echo "‚ö†Ô∏è Nome de arquivo pode conter caracteres n√£o padr√£o"
          fi
          
          # Verificar extens√µes conhecidas
          known_extensions=("js" "ts" "jsx" "tsx" "py" "java" "cpp" "c" "h" "json" "yaml" "yml" "md" "txt" "html" "css" "sql" "sh" "bash" "zsh")
          if [[ " ${known_extensions[@]} " =~ " ${FILE_EXT} " ]]; then
            echo "‚úÖ Extens√£o de arquivo conhecida: $FILE_EXT"
          else
            echo "‚ö†Ô∏è Extens√£o de arquivo n√£o conhecida: $FILE_EXT"
          fi
          ;;
          
        "deep")
          # Valida√ß√£o profunda
          echo "üìã Valida√ß√£o profunda:"
          
          # Executar todas as valida√ß√µes abrangentes
          # (c√≥digo da valida√ß√£o abrangente aqui)
          
          # Verifica√ß√£o adicional de checksum
          if [ -f "$NORMALIZED_PATH" ]; then
            echo "üîç Calculando checksum do arquivo..."
            checksum=$(sha256sum "$NORMALIZED_PATH" | cut -d' ' -f1)
            echo "üîê SHA256: $checksum"
            
            # Verificar se o arquivo √© execut√°vel
            if [ -x "$NORMALIZED_PATH" ]; then
              echo "‚ö†Ô∏è Arquivo √© execut√°vel"
              
              # Verificar assinatura b√°sica
              if command -v file &> /dev/null; then
                file_type=$(file "$NORMALIZED_PATH")
                echo "üìä Tipo de arquivo: $file_type"
              fi
            fi
            
            # Verificar encoding para arquivos de texto
            if command -v file &> /dev/null && file "$NORMALIZED_PATH" | grep -q "text"; then
              encoding=$(file -i "$NORMALIZED_PATH" | cut -d'=' -f2)
              echo "üìù Encoding: $encoding"
            fi
          fi
          
          # Verificar links simb√≥licos
          if [ -L "$NORMALIZED_PATH" ]; then
            echo "üîó Arquivo √© um link simb√≥lico"
            target=$(readlink -f "$NORMALIZED_PATH")
            echo "üéØ Alvo do link: $target"
            
            if [ ! -e "$target" ]; then
              echo "‚ùå Link simb√≥lico quebrado"
              
              if [ "$auto_recovery" = "true" ]; then
                echo "üõ†Ô∏è Tentando reparar link simb√≥lico..."
                # Buscar o alvo em locais alternativos
                target_name=$(basename "$target")
                possible_targets=$(find / -name "$target_name" 2>/dev/null | head -5)
                
                if [ -n "$possible_targets" ]; then
                  new_target=$(echo "$possible_targets" | head -1)
                  ln -sf "$new_target" "$NORMALIZED_PATH"
                  echo "‚úÖ Link simb√≥lico reparado para: $new_target"
                else
                  echo "‚ùå N√£o foi poss√≠vel encontrar o alvo do link"
                fi
              fi
            fi
          fi
          ;;
      esac
      
      echo "‚úÖ Valida√ß√£o $validation_level conclu√≠da"

  - name: "generate_validation_report"
    run: |
      # Gerar relat√≥rio detalhado da valida√ß√£o
      echo "üìä Gerando relat√≥rio de valida√ß√£o..."
      
      validation_report="/tmp/validation_report_$(date +%s).md"
      cat > "$validation_report" << EOF
# Relat√≥rio de Valida√ß√£o de Sistema de Arquivos

## üìä Informa√ß√µes Gerais
- **Caminho Validado:** $NORMALIZED_PATH
- **Tipo de Opera√ß√£o:** $operation_type
- **N√≠vel de Valida√ß√£o:** $validation_level
- **Recupera√ß√£o Autom√°tica:** $auto_recovery
- **Status:** ‚úÖ Conclu√≠do com sucesso

## üìÅ Informa√ß√µes do Arquivo
- **Diret√≥rio:** $DIR_PATH
- **Nome do Arquivo:** $FILE_NAME
- **Extens√£o:** $FILE_EXT
- **Caminho Normalizado:** $NORMALIZED_PATH

## ‚úÖ Valida√ß√µes Realizadas
- [x] Normaliza√ß√£o e valida√ß√£o de caminho
- [x] Verifica√ß√£o de pr√©-requisitos
- [x] Valida√ß√£o de exist√™ncia do arquivo
- [x] Valida√ß√£o de integridade do arquivo
- [x] Valida√ß√£o abrangente ($validation_level)

## üõ°Ô∏è Medidas de Seguran√ßa Aplicadas
- [x] Valida√ß√£o de caracteres perigosos
- [x] Verifica√ß√£o de permiss√µes
- [x] Verifica√ß√£o de espa√ßo em disco
- [x] Cria√ß√£o de backups autom√°ticos
- [x] Recupera√ß√£o de arquivos perdidos
- [x] Corre√ß√£o de permiss√µes
- [x] Reparo de arquivos corrompidos

## üìä Resultados da Valida√ß√£o
- **Status do Arquivo:** $([ -f "$NORMALIZED_PATH" ] && echo "‚úÖ Existe" || echo "‚ùå N√£o existe")
- **Permiss√µes de Leitura:** $([ -r "$NORMALIZED_PATH" ] && echo "‚úÖ OK" || echo "‚ùå Negado")
- **Permiss√µes de Escrita:** $([ -w "$NORMALIZED_PATH" ] && echo "‚úÖ OK" || echo "‚ùå Negado")
- **Integridade:** $([ -f "$NORMALIZED_PATH" ] && [ -s "$NORMALIZED_PATH" ] && echo "‚úÖ OK" || echo "‚ö†Ô∏è Problemas")
- **Tamanho:** $([ -f "$NORMALIZED_PATH" ] && stat -c%s "$NORMALIZED_PATH" 2>/dev/null || echo "0") bytes

## üîÑ A√ß√µes de Recupera√ß√£o Realizadas
$(if [ "$auto_recovery" = "true" ]; then
  echo "- [x] Recupera√ß√£o autom√°tica habilitada"
  echo "- [x] Estrat√©gias de recupera√ß√£o aplicadas"
  echo "- [x] Backups criados quando necess√°rio"
  echo "- [x] Permiss√µes corrigidas"
  echo "- [x] Arquivos corrompidos recuperados"
else
  echo "- [ ] Recupera√ß√£o autom√°tica desabilitada"
fi)

## üìã Recomenda√ß√µes
$(if [ -f "$NORMALIZED_PATH" ]; then
  echo "- ‚úÖ Arquivo est√° pronto para a opera√ß√£o $operation_type"
  echo "- üîç Continue monitorando a integridade do arquivo"
  echo "- üíæ Considere criar backups regulares"
else
  echo "- ‚ö†Ô∏è Arquivo n√£o foi encontrado ou recuperado"
  echo "- üîß Verifique se o caminho est√° correto"
  echo "- üìÅ Considere criar o arquivo manualmente"
fi)

---
*Relat√≥rio gerado em: $(date)*
*Vers√£o: 1.0*
*Sistema: Kilo Code File System Validator*
EOF
      
      echo "üìä Relat√≥rio de valida√ß√£o gerado: $validation_report"
      echo "VALIDATION_REPORT=$validation_report" >> $GITHUB_ENV

  - name: "final_validation"
    run: |
      # Valida√ß√£o final e prepara√ß√£o para opera√ß√£o
      echo "‚úÖ Realizando valida√ß√£o final..."
      
      # Verificar status final
      final_status="success"
      
      if [ ! -f "$NORMALIZED_PATH" ] && [ "$operation_type" = "read" ]; then
        final_status="file_not_found"
      elif [ ! -r "$NORMALIZED_PATH" ]; then
        final_status="permission_denied"
      elif [ ! -w "$NORMALIZED_PATH" ] && [[ "$operation_type" =~ (write|create|delete|move|copy) ]]; then
        final_status="write_permission_denied"
      elif [ -f "$NORMALIZED_PATH" ] && [ ! -s "$NORMALIZED_PATH" ]; then
        final_status="empty_file"
      fi
      
      echo "FINAL_STATUS=$final_status" >> $GITHUB_ENV
      
      case "$final_status" in
        "success")
          echo "üéâ Valida√ß√£o conclu√≠da com sucesso!"
          echo "‚úÖ Arquivo est√° pronto para opera√ß√£o: $operation_type"
          ;;
        "file_not_found")
          echo "‚ùå Valida√ß√£o falhou: arquivo n√£o encontrado"
          exit 1
          ;;
        "permission_denied")
          echo "‚ùå Valida√ß√£o falhou: permiss√£o de leitura negada"
          exit 1
          ;;
        "write_permission_denied")
          echo "‚ùå Valida√ß√£o falhou: permiss√£o de escrita negada"
          exit 1
          ;;
        "empty_file")
          echo "‚ö†Ô∏è Valida√ß√£o conclu√≠da com advert√™ncia: arquivo vazio"
          ;;
      esac
      
      # Preparar resultado para opera√ß√£o subsequente
      echo "OPERATION_READY=true" >> $GITHUB_ENV
      echo "VALIDATED_PATH=$NORMALIZED_PATH" >> $GITHUB_ENV

error_handling:
  - step: "normalize_and_validate_path"
    on_error: "exit_with_error"
    message: "Caminho inv√°lido ou normaliza√ß√£o falhou"
    
  - step: "check_prerequisites"
    on_error: "exit_with_error"
    message: "Pr√©-requisitos n√£o atendidos"
    
  - step: "validate_file_existence"
    on_error: "continue"
    message: "Falha na valida√ß√£o de exist√™ncia, tentando recupera√ß√£o"
    
  - step: "validate_file_integrity"
    on_error: "continue"
    message: "Falha na valida√ß√£o de integridade, continuando com advert√™ncias"
    
  - step: "perform_comprehensive_validation"
    on_error: "continue"
    message: "Falha na valida√ß√£o abrangente, usando resultados b√°sicos"
    
  - step: "generate_validation_report"
    on_error: "continue"
    message: "Falha ao gerar relat√≥rio, continuando sem documenta√ß√£o"
    
  - step: "final_validation"
    on_error: "exit_with_error"
    message: "Falha cr√≠tica na valida√ß√£o final"

examples:
  - name: "Valida√ß√£o B√°sica de Leitura"
    description: "Validar arquivo para opera√ß√£o de leitura"
    command: "killo action file_system_validator --target_path=/projeto/src/app.js --operation_type=read --validation_level=basic"
    
  - name: "Valida√ß√£o Abrangente de Escrita"
    description: "Validar arquivo para opera√ß√£o de escrita com recupera√ß√£o autom√°tica"
    command: "killo action file_system_validator --target_path=/projeto/config.json --operation_type=write --validation_level=comprehensive --auto_recovery=true"
    
  - name: "Valida√ß√£o Profunda de Cria√ß√£o"
    description: "Valida√ß√£o profunda para cria√ß√£o de novo arquivo"
    command: "killo action file_system_validator --target_path=/projeto/tests/unit/service.test.js --operation_type=create --validation_level=deep --auto_recovery=true"

integration:
  vscode:
    command: "killo.action.file_system_validator"
    parameters:
      target_path: "${file}"
      operation_type: "--operation_type"
      validation_level: "--validation_level"
      auto_recovery: "--auto_recovery"
  
  terminal:
    command: "killo action file_system_validator"
    parameters:
      target_path: "--target_path"
      operation_type: "--operation_type"
      validation_level: "--validation_level"
      auto_recovery: "--auto_recovery"

output_formats:
  - name: "validation_report"
    description: "Relat√≥rio completo da valida√ß√£o"
    parameter: "--output=report"
    
  - name: "status_only"
    description: "Apenas status da valida√ß√£o"
    parameter: "--output=status"
    
  - name: "detailed_info"
    description: "Informa√ß√µes detalhadas do arquivo"
    parameter: "--output=detailed"