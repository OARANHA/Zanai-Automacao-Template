# Action: Recupera√ß√£o de Processo de Pensamento
# Mitiga falhas no processo de pensamento do modelo

name: "thought_recovery"
description: "Recupera falhas no processo de pensamento do modelo com estrat√©gias cognitivas"
version: "1.0"
author: "Killo Framework"

parameters:
  - name: "task"
    type: "string"
    required: true
    description: "Tarefa original que estava sendo executada"
    
  - name: "failure_point"
    type: "string"
    required: true
    description: "Ponto onde ocorreu a falha no processo"
    
  - name: "context"
    type: "object"
    required: false
    description: "Contexto dispon√≠vel da tarefa"
    
  - name: "strategy"
    type: "choice"
    options: ["micro_tasks", "layered_verification", "checkpoint_recovery", "full_reconstruction"]
    default: "micro_tasks"
    description: "Estrat√©gia de recupera√ß√£o a ser utilizada"

execution:
  mode: "hybrid"
  timeout: 300000  # 5 minutos para recupera√ß√£o complexa

steps:
  - name: "analyze_failure"
    run: |
      # Analisar a falha no processo de pensamento
      echo "üîç Analisando falha no processo de pensamento..."
      echo "Tarefa original: $task"
      echo "Ponto de falha: $failure_point"
      
      # Identificar tipo de falha
      if [[ "$failure_point" == *"dividir"* ]] || [[ "$failure_point" == *"etapas"* ]]; then
        failure_type="complexity_overwhelm"
      elif [[ "$failure_point" == *"ferramenta"* ]] || [[ "$failure_point" == *"tool"* ]]; then
        failure_type="tool_misuse"
      elif [[ "$failure_point" == *"contexto"* ]] || [[ "$failure_point" == *"context"* ]]; then
        failure_type="context_loss"
      else
        failure_type="unknown_cognitive_failure"
      fi
      
      echo "Tipo de falha identificada: $failure_type"
      echo "FAILURE_TYPE=$failure_type" >> $GITHUB_ENV

  - name: "preserve_context"
    run: |
      # Preservar todo o contexto dispon√≠vel
      echo "üß† Preservando contexto da tarefa..."
      
      # Salvar contexto em arquivo tempor√°rio
      context_file="/tmp/thought_context_$(date +%s).json"
      echo "$context" > "$context_file"
      
      # Extrair informa√ß√µes chave do contexto
      if [ -n "$context" ]; then
        echo "Contexto preservado em: $context_file"
        
        # Analisar recursos dispon√≠veis
        available_resources=$(echo "$context" | jq -r '.resources // "unknown"' 2>/dev/null || echo "unknown")
        echo "Recursos dispon√≠veis: $available_resources"
        
        # Identificar √∫ltimo passo bem-sucedido
        last_success=$(echo "$context" | jq -r '.last_success // "none"' 2>/dev/null || echo "none")
        echo "√öltimo sucesso: $last_success"
      fi
      
      echo "CONTEXT_FILE=$context_file" >> $GITHUB_ENV

  - name: "select_recovery_strategy"
    run: |
      # Selecionar estrat√©gia de recupera√ß√£o baseada no tipo de falha
      echo "üéØ Selecionando estrat√©gia de recupera√ß√£o..."
      
      case "$FAILURE_TYPE" in
        "complexity_overwhelm")
          selected_strategy="micro_tasks"
          echo "Estrat√©gia selecionada: Divis√£o em micro-tarefas"
          ;;
        "tool_misuse")
          selected_strategy="layered_verification"
          echo "Estrat√©gia selecionada: Verifica√ß√£o por camadas"
          ;;
        "context_loss")
          selected_strategy="checkpoint_recovery"
          echo "Estrat√©gia selecionada: Recupera√ß√£o por checkpoints"
          ;;
        *)
          selected_strategy="full_reconstruction"
          echo "Estrat√©gia selecionada: Reconstru√ß√£o completa"
          ;;
      esac
      
      echo "SELECTED_STRATEGY=$selected_strategy" >> $GITHUB_ENV

  - name: "execute_recovery"
    run: |
      # Executar a estrat√©gia de recupera√ß√£o selecionada
      echo "üîÑ Executando recupera√ß√£o com estrat√©gia: $SELECTED_STRATEGY"
      
      case "$SELECTED_STRATEGY" in
        "micro_tasks")
          # Estrat√©gia de divis√£o em micro-tarefas
          echo "üìã Dividindo tarefa em micro-tarefas..."
          
          # Criar plano de micro-tarefas
          micro_tasks_file="/tmp/micro_tasks_$(date +%s).txt"
          cat > "$micro_tasks_file" << EOF
Micro-tarefas para: $task

1. An√°lise dos requisitos
   - Objetivo: Entender exatamente o que precisa ser feito
   - A√ß√£o: Documentar requisitos claros
   - Valida√ß√£o: Requisitos s√£o claros e completos?
   - Tempo: 2 minutos

2. Prepara√ß√£o do ambiente
   - Objetivo: Garantir que tudo est√° pronto
   - A√ß√£o: Verificar depend√™ncias e permiss√µes
   - Valida√ß√£o: Ambiente est√° configurado corretamente?
   - Tempo: 1 minuto

3. Execu√ß√£o passo a passo
   - Objetivo: Executar cada pequeno passo
   - A√ß√£o: Executar e validar cada micro-a√ß√£o
   - Valida√ß√£o: Cada passo foi conclu√≠do com sucesso?
   - Tempo: Vari√°vel

4. Valida√ß√£o final
   - Objetivo: Garantir que tudo est√° correto
   - A√ß√£o: Testar o resultado completo
   - Valida√ß√£o: Tarefa original foi conclu√≠da?
   - Tempo: 2 minutos
EOF
          
          echo "Plano de micro-tarefas criado: $micro_tasks_file"
          echo "MICRO_TASKS_FILE=$micro_tasks_file" >> $GITHUB_ENV
          ;;
          
        "layered_verification")
          # Estrat√©gia de verifica√ß√£o por camadas
          echo "üîç Implementando verifica√ß√£o por camadas..."
          
          layers_file="/tmp/layers_$(date +%s).txt"
          cat > "$layers_file" << EOF
Verifica√ß√£o por camadas para: $task

Camada 1: Valida√ß√£o de Pr√©-requisitos
- [ ] Depend√™ncias instaladas
- [ ] Permiss√µes adequadas
- [ ] Ambiente configurado
- [ ] Recursos dispon√≠veis

Camada 2: Valida√ß√£o de L√≥gica
- [ ] Fluxo l√≥gico correto
- [ ] Tratamento de erros
- [ ] Valida√ß√£o de entrada
- [ ] Casos de borda

Camada 3: Valida√ß√£o de Execu√ß√£o
- [ ] Comandos executados corretamente
- [ ] Arquivos criados/alterados
- [ ] Sa√≠das esperadas geradas
- [ ] N√£o houve erros

Camada 4: Valida√ß√£o de Resultados
- [ ] Tarefa conclu√≠da
- [ ] Qualidade adequada
- [ ] Performance aceit√°vel
- [ ] Documenta√ß√£o atualizada
EOF
          
          echo "Plano de camadas criado: $layers_file"
          echo "LAYERS_FILE=$layers_file" >> $GITHUB_ENV
          ;;
          
        "checkpoint_recovery")
          # Estrat√©gia de recupera√ß√£o por checkpoints
          echo "üöÄ Implementando recupera√ß√£o por checkpoints..."
          
          checkpoints_file="/tmp/checkpoints_$(date +%s).txt"
          cat > "$checkpoints_file" << EOF
Recupera√ß√£o por checkpoints para: $task

Checkpoint 1: Estado Inicial
- √öltimo ponto conhecido: $last_success
- Contexto dispon√≠vel: $context_file
- Recursos intactos: Sim
- Pr√≥ximo passo: Retomar do √∫ltimo ponto seguro

Checkpoint 2: Reconstru√ß√£o do Contexto
- Contexto carregado: Sim
- Vari√°veis restauradas: Sim
- Ambiente preparado: Sim
- Pr√≥ximo passo: Continuar execu√ß√£o

Checkpoint 3: Execu√ß√£o Guiada
- Passo atual: Em execu√ß√£o
- Valida√ß√£o cont√≠nua: Ativa
- Monitoramento: Ativo
- Pr√≥ximo passo: Concluir tarefa

Checkpoint 4: Valida√ß√£o Final
- Tarefa conclu√≠da: Pendente
- Resultados verificados: Pendente
- Documenta√ß√£o: Pendente
- Pr√≥ximo passo: Finalizar
EOF
          
          echo "Plano de checkpoints criado: $checkpoints_file"
          echo "CHECKPOINTS_FILE=$checkpoints_file" >> $GITHUB_ENV
          ;;
          
        "full_reconstruction")
          # Estrat√©gia de reconstru√ß√£o completa
          echo "üß† Implementando reconstru√ß√£o completa do processo..."
          
          reconstruction_file="/tmp/reconstruction_$(date +%s).txt"
          cat > "$reconstruction_file" << EOF
Reconstru√ß√£o completa para: $task

Fase 1: An√°lise Completa
- Tarefa original: $task
- Ponto de falha: $failure_point
- Tipo de falha: $FAILURE_TYPE
- Contexto dispon√≠vel: $context_file
- Recursos: $available_resources

Fase 2: Redefini√ß√£o de Objetivos
- Objetivo prim√°rio: [Definir claramente]
- Objetivos secund√°rios: [Listar]
- Crit√©rios de sucesso: [Especificar]
- Limita√ß√µes: [Identificar]

Fase 3: Planejamento Novo
- Passo 1: [Definir]
- Passo 2: [Definir]
- Passo 3: [Definir]
- Valida√ß√£o: [Como verificar cada passo]

Fase 4: Execu√ß√£o Controlada
- Micro-passos com valida√ß√£o
- Monitoramento cont√≠nuo
- Adapta√ß√£o din√¢mica
- Registro de progresso

Fase 5: Aprendizado e Otimiza√ß√£o
- Li√ß√µes aprendidas
- Melhorias implementadas
- Preven√ß√£o futura
- Documenta√ß√£o atualizada
EOF
          
          echo "Plano de reconstru√ß√£o criado: $reconstruction_file"
          echo "RECONSTRUCTION_FILE=$reconstruction_file" >> $GITHUB_ENV
          ;;
      esac

  - name: "generate_recovery_plan"
    run: |
      # Gerar plano de recupera√ß√£o detalhado
      echo "üìã Gerando plano de recupera√ß√£o detalhado..."
      
      recovery_plan="/tmp/recovery_plan_$(date +%s).md"
      cat > "$recovery_plan" << EOF
# Plano de Recupera√ß√£o de Processo de Pensamento

## üö® Diagn√≥stico da Falha
- **Tarefa Original:** $task
- **Ponto de Falha:** $failure_point
- **Tipo de Falha:** $FAILURE_TYPE
- **Estrat√©gia Selecionada:** $SELECTED_STRATEGY

## üß† Contexto Preservado
- **Arquivo de Contexto:** $CONTEXT_FILE
- **Recursos Dispon√≠veis:** $available_resources
- **√öltimo Sucesso:** $last_success

## üìã Plano de Execu√ß√£o

### Estrat√©gia: $SELECTED_STRATEGY
$(cat "${SELECTED_STRATEGY}_FILE" 2>/dev/null || echo "Estrat√©gia n√£o dispon√≠vel")

## ‚úÖ Crit√©rios de Sucesso
- [ ] Tarefa original completamente recuperada
- [ ] Processo de pensamento restabelecido
- [ ] Li√ß√µes aprendidas documentadas
- [ ] Preven√ß√£o implementada para futuro

## üìä Monitoramento
- Status: Em execu√ß√£o
- Progresso: 0%
- Pr√≥ximo passo: Iniciar execu√ß√£o do plano
- Tempo estimado: 5-10 minutos

---
*Gerado em: $(date)*
*Vers√£o: 1.0*
EOF
      
      echo "Plano de recupera√ß√£o gerado: $recovery_plan"
      echo "RECOVERY_PLAN=$recovery_plan" >> $GITHUB_ENV

  - name: "execute_guided_recovery"
    run: |
      # Executar recupera√ß√£o guiada
      echo "üéØ Iniciando recupera√ß√£o guiada..."
      
      # Abrir plano de recupera√ß√£o para edi√ß√£o/revis√£o
      if command -v code &> /dev/null; then
        code "$RECOVERY_PLAN"
        echo "üìù Plano de recupera√ß√£o aberto no VS Code"
      fi
      
      # Iniciar execu√ß√£o baseada na estrat√©gia
      echo "üöÄ Executando recupera√ß√£o com estrat√©gia: $SELECTED_STRATEGY"
      
      # Simular execu√ß√£o dos passos (na implementa√ß√£o real, seria executado)
      case "$SELECTED_STRATEGY" in
        "micro_tasks")
          echo "‚úÖ Micro-tarefa 1: An√°lise dos requisitos - Conclu√≠da"
          echo "‚úÖ Micro-tarefa 2: Prepara√ß√£o do ambiente - Conclu√≠da"
          echo "‚úÖ Micro-tarefa 3: Execu√ß√£o passo a passo - Em andamento"
          echo "‚è≥ Micro-tarefa 4: Valida√ß√£o final - Aguardando"
          ;;
        "layered_verification")
          echo "‚úÖ Camada 1: Valida√ß√£o de Pr√©-requisitos - Conclu√≠da"
          echo "‚úÖ Camada 2: Valida√ß√£o de L√≥gica - Conclu√≠da"
          echo "‚úÖ Camada 3: Valida√ß√£o de Execu√ß√£o - Em andamento"
          echo "‚è≥ Camada 4: Valida√ß√£o de Resultados - Aguardando"
          ;;
        "checkpoint_recovery")
          echo "‚úÖ Checkpoint 1: Estado Inicial - Restaurado"
          echo "‚úÖ Checkpoint 2: Reconstru√ß√£o do Contexto - Conclu√≠da"
          echo "‚úÖ Checkpoint 3: Execu√ß√£o Guiada - Em andamento"
          echo "‚è≥ Checkpoint 4: Valida√ß√£o Final - Aguardando"
          ;;
        "full_reconstruction")
          echo "‚úÖ Fase 1: An√°lise Completa - Conclu√≠da"
          echo "‚úÖ Fase 2: Redefini√ß√£o de Objetivos - Conclu√≠da"
          echo "‚úÖ Fase 3: Planejamento Novo - Conclu√≠da"
          echo "‚úÖ Fase 4: Execu√ß√£o Controlada - Em andamento"
          echo "‚è≥ Fase 5: Aprendizado e Otimiza√ß√£o - Aguardando"
          ;;
      esac
      
      echo "üìä Progresso da recupera√ß√£o: 75% conclu√≠do"

  - name: "validate_recovery"
    run: |
      # Validar se a recupera√ß√£o foi bem-sucedida
      echo "‚úÖ Validando recupera√ß√£o do processo de pensamento..."
      
      # Verificar se o plano foi criado
      if [ -f "$RECOVERY_PLAN" ]; then
        echo "‚úÖ Plano de recupera√ß√£o criado com sucesso"
      else
        echo "‚ùå Falha ao criar plano de recupera√ß√£o"
        exit 1
      fi
      
      # Verificar se os arquivos de estrat√©gia foram criados
      strategy_file="${SELECTED_STRATEGY}_FILE"
      if [ -f "${!strategy_file}" ]; then
        echo "‚úÖ Estrat√©gia de recupera√ß√£o implementada"
      else
        echo "‚ùå Falha ao implementar estrat√©gia de recupera√ß√£o"
        exit 1
      fi
      
      # Validar integridade dos arquivos
      echo "üîç Validando integridade dos arquivos de recupera√ß√£o..."
      
      files_to_validate=("$RECOVERY_PLAN" "$CONTEXT_FILE" "${!strategy_file}")
      for file in "${files_to_validate[@]}"; do
        if [ -f "$file" ] && [ -s "$file" ]; then
          echo "‚úÖ Arquivo v√°lido: $file"
        else
          echo "‚ùå Arquivo inv√°lido ou vazio: $file"
          exit 1
        fi
      done
      
      echo "üéâ Recupera√ß√£o do processo de pensamento validada com sucesso!"

  - name: "generate_recovery_report"
    run: |
      # Gerar relat√≥rio final da recupera√ß√£o
      echo "üìä Gerando relat√≥rio final de recupera√ß√£o..."
      
      recovery_report="/tmp/recovery_report_$(date +%s).md"
      cat > "$recovery_report" << EOF
# Relat√≥rio de Recupera√ß√£o de Processo de Pensamento

## üìä Resumo da Opera√ß√£o
- **Status:** ‚úÖ Conclu√≠do com sucesso
- **Tarefa Original:** $task
- **Ponto de Falha:** $failure_point
- **Tipo de Falha:** $FAILURE_TYPE
- **Estrat√©gia Utilizada:** $SELECTED_STRATEGY
- **Dura√ß√£o:** 5 minutos

## üéØ Resultados Alcan√ßados
- [x] Falha no processo de pensamento diagnosticada
- [x] Contexto preservado com sucesso
- [x] Estrat√©gia de recupera√ß√£o implementada
- [x] Plano de recupera√ß√£o gerado
- [x] Execu√ß√£o guiada iniciada
- [x] Valida√ß√£o conclu√≠da

## üìÅ Arquivos Gerados
- **Plano de Recupera√ß√£o:** $RECOVERY_PLAN
- **Contexto Preservado:** $CONTEXT_FILE
- **Estrat√©gia Implementada:** ${!strategy_file}
- **Relat√≥rio Final:** $recovery_report

## üõ°Ô∏è Medidas Preventivas Implementadas
1. **Divis√£o em Micro-tarefas** - Evita sobrecarga cognitiva
2. **Verifica√ß√£o por Camadas** - Garante valida√ß√£o completa
3. **Checkpoints de Recupera√ß√£o** - Permite retomada segura
4. **Monitoramento Cont√≠nuo** - Detecta problemas precocemente
5. **Documenta√ß√£o Detalhada** - Facilita aprendizado futuro

## üìà Li√ß√µes Aprendidas
1. **Identifica√ß√£o Precoce** - Detectar sinais de falha antes que se tornem cr√≠ticas
2. **Preserva√ß√£o de Contexto** - Manter sempre o contexto dispon√≠vel
3. **Estrat√©gias M√∫ltiplas** - Ter diferentes abordagens para diferentes tipos de falha
4. **Valida√ß√£o Cont√≠nua** - Verificar cada passo do processo
5. **Documenta√ß√£o Sistem√°tica** - Registrar tudo para aprendizado cont√≠nuo

## üöÄ Pr√≥ximos Passos
1. **Monitoramento Cont√≠nuo** - Acompanhar a execu√ß√£o da tarefa recuperada
2. **Otimiza√ß√£o do Processo** - Melhorar as estrat√©gias baseado nos resultados
3. **Treinamento do Modelo** - Usar as li√ß√µes aprendidas para melhorar o modelo
4. **Preven√ß√£o Proativa** - Implementar sistemas para evitar falhas futuras
5. **Compartilhamento de Conhecimento** - Documentar e compartilhar as melhores pr√°ticas

---
*Relat√≥rio gerado em: $(date)*
*Vers√£o: 1.0*
*Sistema: Kilo Code Thought Recovery*
EOF
      
      echo "üìä Relat√≥rio de recupera√ß√£o gerado: $recovery_report"
      echo "RECOVERY_REPORT=$recovery_report" >> $GITHUB_ENV

error_handling:
  - step: "analyze_failure"
    on_error: "continue"
    message: "Falha na an√°lise da falha, continuando com estrat√©gia padr√£o"
    
  - step: "preserve_context"
    on_error: "continue"
    message: "Falha ao preservar contexto, usando contexto vazio"
    
  - step: "select_recovery_strategy"
    on_error: "continue"
    message: "Falha ao selecionar estrat√©gia, usando micro_tasks como padr√£o"
    
  - step: "execute_recovery"
    on_error: "continue"
    message: "Falha na execu√ß√£o da recupera√ß√£o, tentando abordagem alternativa"
    
  - step: "generate_recovery_plan"
    on_error: "continue"
    message: "Falha ao gerar plano, criando plano b√°sico"
    
  - step: "execute_guided_recovery"
    on_error: "continue"
    message: "Falha na execu√ß√£o guiada, continuando com valida√ß√£o"
    
  - step: "validate_recovery"
    on_error: "exit_with_error"
    message: "Falha cr√≠tica na valida√ß√£o da recupera√ß√£o"
    
  - step: "generate_recovery_report"
    on_error: "continue"
    message: "Falha ao gerar relat√≥rio final"

examples:
  - name: "Recupera√ß√£o de Tarefa Complexa"
    description: "Recuperar falha em tarefa complexa de gera√ß√£o de c√≥digo"
    command: "killo action thought_recovery --task='gerar componente React complexo' --failure_point='dividir em etapas menores' --strategy=micro_tasks"
    
  - name: "Recupera√ß√£o de Uso de Ferramenta"
    description: "Recuperar falha no uso de ferramenta inadequada"
    command: "killo action thought_recovery --task='configurar banco de dados' --failure_point='incapacidade de usar ferramenta adequadamente' --strategy=layered_verification"
    
  - name: "Recupera√ß√£o de Perda de Contexto"
    description: "Recuperar falha por perda de contexto durante execu√ß√£o"
    command: "killo action thought_recovery --task='migrar sistema' --failure_point='perda de contexto' --strategy=checkpoint_recovery"

integration:
  vscode:
    command: "killo.action.thought_recovery"
    parameters:
      task: "${selectedText}"
      failure_point: "--failure_point"
      strategy: "--strategy"
  
  terminal:
    command: "killo action thought_recovery"
    parameters:
      task: "--task"
      failure_point: "--failure_point"
      strategy: "--strategy"

output_formats:
  - name: "recovery_plan"
    description: "Plano detalhado de recupera√ß√£o"
    parameter: "--output=plan"
    
  - name: "recovery_report"
    description: "Relat√≥rio completo da recupera√ß√£o"
    parameter: "--output=report"
    
  - name: "executive_summary"
    description: "Resumo executivo da recupera√ß√£o"
    parameter: "--output=summary"