# .killo-workspace/agent/actions/file-recovery.yaml
name: "file_recovery"
description: "Recupera arquivos n√£o encontrados e resolve problemas de caminhos e permiss√µes"
version: "1.0"
author: "Killo Framework"

parameters:
  - name: "file_path"
    type: "string"
    required: true
    description: "Caminho do arquivo que n√£o foi encontrado"
  
  - name: "error_message"
    type: "string"
    required: true
    description: "Mensagem de erro espec√≠fica"
  
  - name: "search_strategy"
    type: "choice"
    options: ["hierarchical", "pattern_matching", "structure_sync", "backup_restore"]
    default: "hierarchical"
    description: "Estrat√©gia de busca e recupera√ß√£o"
  
  - name: "create_if_missing"
    type: "boolean"
    default: true
    description: "Criar arquivo se n√£o for encontrado"
  
  - name: "backup_existing"
    type: "boolean"
    default: true
    description: "Fazer backup de arquivos existentes antes de modificar"

execution:
  mode: "hybrid"
  timeout: 180

steps:
  - name: "analyze_file_error"
    run: |
      # Analisar o erro de arquivo
      echo "üîç Analisando erro de arquivo..."
      echo "Arquivo: $file_path"
      echo "Erro: $error_message"
      
      # Extrair informa√ß√µes do caminho
      dir_path=$(dirname "$file_path")
      file_name=$(basename "$file_path")
      file_ext="${file_name##*.}"
      file_base="${file_name%.*}"
      
      echo "Diret√≥rio: $dir_path"
      echo "Nome do arquivo: $file_name"
      echo "Extens√£o: $file_ext"
      echo "Base: $file_base"
      
      # Salvar informa√ß√µes para uso posterior
      echo "dir_path=$dir_path" > /tmp/file_recovery_context.txt
      echo "file_name=$file_name" >> /tmp/file_recovery_context.txt
      echo "file_ext=$file_ext" >> /tmp/file_recovery_context.txt
      echo "file_base=$file_base" >> /tmp/file_recovery_context.txt
      
      # Analisar tipo de erro
      if [[ "$error_message" == *"not found"* ]]; then
        error_type="not_found"
      elif [[ "$error_message" == *"permission"* ]]; then
        error_type="permission"
      elif [[ "$error_message" == *"no such file"* ]]; then
        error_type="no_such_file"
      elif [[ "$error_message" == *"is a directory"* ]]; then
        error_type="is_directory"
      else
        error_type="unknown"
      fi
      
      echo "Tipo de erro: $error_type"
      echo "error_type=$error_type" >> /tmp/file_recovery_context.txt

  - name: "check_file_existence"
    run: |
      # Verificar se o arquivo realmente existe
      echo "üîç Verificando exist√™ncia do arquivo..."
      
      # Carregar contexto
      source /tmp/file_recovery_context.txt
      
      # Verificar arquivo
      if [ -f "$file_path" ]; then
        echo "‚úÖ Arquivo existe no caminho especificado"
        file_exists=true
        
        # Verificar permiss√µes
        if [ -r "$file_path" ]; then
          echo "‚úÖ Arquivo √© leg√≠vel"
          readable=true
        else
          echo "‚ùå Arquivo n√£o √© leg√≠vel"
          readable=false
        fi
        
        if [ -w "$file_path" ]; then
          echo "‚úÖ Arquivo √© grav√°vel"
          writable=true
        else
          echo "‚ùå Arquivo n√£o √© grav√°vel"
          writable=false
        fi
        
      else
        echo "‚ùå Arquivo n√£o existe no caminho especificado"
        file_exists=false
        readable=false
        writable=false
      fi
      
      # Salvar status
      echo "file_exists=$file_exists" >> /tmp/file_recovery_context.txt
      echo "readable=$readable" >> /tmp/file_recovery_context.txt
      echo "writable=$writable" >> /tmp/file_recovery_context.txt

  - name: "search_alternative_locations"
    run: |
      # Buscar arquivo em locais alternativos
      echo "üîç Buscando arquivo em locais alternativos..."
      
      # Carregar contexto
      source /tmp/file_recovery_context.txt
      
      # Se arquivo n√£o existe, buscar alternativas
      if [ "$file_exists" = false ]; then
        echo "Iniciando busca por arquivo alternativo..."
        
        # Estrat√©gias de busca baseadas no tipo de arquivo
        case "$search_strategy" in
          "hierarchical")
            # Busca hier√°rquica
            search_paths=(
              "$file_path"
              "./$file_name"
              "../$file_name"
              "./$file_base/$file_name"
              "./src/$file_name"
              "./lib/$file_name"
              "./test/$file_name"
              "./tests/$file_name"
              "./spec/$file_name"
              "./__tests__/$file_name"
            )
            ;;
          "pattern_matching")
            # Busca por padr√£o
            search_paths=()
            # Usar find para buscar por padr√£o
            echo "Buscando por padr√£o: *$file_base*.$file_ext"
            while IFS= read -r -d '' found_file; do
              search_paths+=("$found_file")
            done < <(find . -name "*$file_base*.$file_ext" -type f -print0 2>/dev/null)
            ;;
          "structure_sync")
            # Sincroniza√ß√£o de estrutura
            search_paths=()
            # Buscar em estruturas padr√£o baseado na extens√£o
            case "$file_ext" in
              "js")
                search_paths=(
                  "./src/$file_name"
                  "./lib/$file_name"
                  "./test/$file_name"
                  "./tests/$file_name"
                )
                ;;
              "test.js")
                search_paths=(
                  "./test/$file_name"
                  "./tests/$file_name"
                  "./spec/$file_name"
                  "./__tests__/$file_name"
                )
                ;;
              "json")
                search_paths=(
                  "./$file_name"
                  "./config/$file_name"
                  "./src/$file_name"
                )
                ;;
            esac
            ;;
          "backup_restore")
            # Busca em backups
            search_paths=()
            # Buscar em locais de backup
            backup_locations=(
              "./.backup/"
              "./backup/"
              "./.git/"
              "./node_modules/.cache/"
            )
            for backup_loc in "${backup_locations[@]}"; do
              if [ -d "$backup_loc" ]; then
                while IFS= read -r -d '' found_file; do
                  search_paths+=("$found_file")
                done < <(find "$backup_loc" -name "*$file_base*.$file_ext" -type f -print0 2>/dev/null)
              fi
            done
            ;;
        esac
        
        # Verificar cada caminho de busca
        found_alternative=false
        for search_path in "${search_paths[@]}"; do
          if [ -f "$search_path" ]; then
            echo "‚úÖ Arquivo encontrado em: $search_path"
            found_alternative=true
            alternative_path="$search_path"
            break
          fi
        done
        
        if [ "$found_alternative" = true ]; then
          echo "alternative_path=$alternative_path" >> /tmp/file_recovery_context.txt
        else
          echo "‚ùå Arquivo n√£o encontrado em nenhum local alternativo"
          echo "alternative_path=" >> /tmp/file_recovery_context.txt
        fi
      else
        echo "Arquivo j√° existe, pulando busca alternativa"
        echo "alternative_path=$file_path" >> /tmp/file_recovery_context.txt
      fi

  - name: "create_missing_structure"
    run: |
      # Criar estrutura de diret√≥rios ausente
      echo "üõ†Ô∏è Criando estrutura de diret√≥rios ausente..."
      
      # Carregar contexto
      source /tmp/file_recovery_context.txt
      
      # Se arquivo n√£o existe e deve ser criado
      if [ "$file_exists" = false ] && [ "$create_if_missing" = true ]; then
        echo "Criando estrutura para: $file_path"
        
        # Criar diret√≥rios pai
        parent_dir=$(dirname "$file_path")
        if [ ! -d "$parent_dir" ]; then
          echo "Criando diret√≥rio: $parent_dir"
          mkdir -p "$parent_dir"
          echo "‚úÖ Diret√≥rio criado: $parent_dir"
        else
          echo "‚úÖ Diret√≥rio j√° existe: $parent_dir"
        fi
        
        # Determinar tipo de arquivo e criar template
        case "$file_ext" in
          "js")
            # Template para arquivo JavaScript
            if [[ "$file_name" == *"test"* ]]; then
              # Template de teste
              cat > "$file_path" << 'EOF'
const { describe, it, expect } = require('@jest/globals');

describe('Template Test', () => {
  it('should pass', () => {
    expect(true).toBe(true);
  });
});
EOF
            else
              # Template de m√≥dulo JavaScript
              cat > "$file_path" << 'EOF'
/**
 * Template Module
 * Generated by Kilo Code File Recovery
 */

module.exports = {
  // Module implementation
};
EOF
            fi
            ;;
          "json")
            # Template para arquivo JSON
            cat > "$file_path" << 'EOF'
{
  "generated": true,
  "recovered": true,
  "timestamp": "$(date -Iseconds)"
}
EOF
            ;;
          "md")
            # Template para arquivo Markdown
            cat > "$file_path" << EOF
# $(echo $file_base | sed 's/_/ /g' | sed 's/-/ /g' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1))substr($i,2)}1')

Generated by Kilo Code File Recovery

## Overview

This file was automatically generated to replace a missing file.

## Content

Add your content here.

EOF
            ;;
          *)
            # Template gen√©rico
            cat > "$file_path" << EOF
# $(echo $file_base | sed 's/_/ /g' | sed 's/-/ /g' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1))substr($i,2)}1')

Generated by Kilo Code File Recovery
File: $file_name
Date: $(date)
EOF
            ;;
        esac
        
        echo "‚úÖ Arquivo criado: $file_path"
        
        # Configurar permiss√µes
        chmod 644 "$file_path"
        echo "‚úÖ Permiss√µes configuradas"
        
        # Atualizar contexto
        echo "file_created=true" >> /tmp/file_recovery_context.txt
        echo "created_path=$file_path" >> /tmp/file_recovery_context.txt
        
      elif [ "$file_exists" = false ] && [ "$create_if_missing" = false ]; then
        echo "‚ö†Ô∏è Arquivo n√£o existe e cria√ß√£o est√° desativada"
        echo "file_created=false" >> /tmp/file_recovery_context.txt
      else
        echo "‚úÖ Arquivo j√° existe"
        echo "file_created=false" >> /tmp/file_recovery_context.txt
      fi

  - name: "fix_permissions"
    run: |
      # Corrigir problemas de permiss√£o
      echo "üîß Corrigindo problemas de permiss√£o..."
      
      # Carregar contexto
      source /tmp/file_recovery_context.txt
      
      # Determinar caminho final do arquivo
      if [ "$file_exists" = true ]; then
        final_path="$file_path"
      elif [ "$file_created" = true ]; then
        final_path="$created_path"
      elif [ -n "$alternative_path" ]; then
        final_path="$alternative_path"
      else
        echo "‚ùå Nenhum arquivo dispon√≠vel para corrigir permiss√µes"
        return 1
      fi
      
      echo "Corrigindo permiss√µes para: $final_path"
      
      # Verificar e corrigir permiss√µes
      if [ -f "$final_path" ]; then
        # Tornar arquivo leg√≠vel
        if [ ! -r "$final_path" ]; then
          chmod +r "$final_path"
          echo "‚úÖ Permiss√£o de leitura adicionada"
        fi
        
        # Tornar arquivo grav√°vel (se apropriado)
        if [ ! -w "$final_path" ]; then
          chmod +w "$final_path"
          echo "‚úÖ Permiss√£o de escrita adicionada"
        fi
        
        # Verificar permiss√µes do diret√≥rio pai
        parent_dir=$(dirname "$final_path")
        if [ ! -x "$parent_dir" ]; then
          chmod +x "$parent_dir"
          echo "‚úÖ Permiss√£o de execu√ß√£o adicionada ao diret√≥rio pai"
        fi
        
        echo "‚úÖ Permiss√µes corrigidas com sucesso"
        echo "final_path=$final_path" >> /tmp/file_recovery_context.txt
        echo "permissions_fixed=true" >> /tmp/file_recovery_context.txt
      else
        echo "‚ùå Arquivo n√£o encontrado para corre√ß√£o de permiss√µes"
        echo "permissions_fixed=false" >> /tmp/file_recovery_context.txt
      fi

  - name: "validate_recovery"
    run: |
      # Validar a recupera√ß√£o do arquivo
      echo "‚úÖ Validando recupera√ß√£o do arquivo..."
      
      # Carregar contexto
      source /tmp/file_recovery_context.txt
      
      # Determinar caminho final validado
      if [ -n "$final_path" ] && [ -f "$final_path" ]; then
        validated_path="$final_path"
      elif [ -f "$file_path" ]; then
        validated_path="$file_path"
      elif [ -n "$alternative_path" ] && [ -f "$alternative_path" ]; then
        validated_path="$alternative_path"
      elif [ -n "$created_path" ] && [ -f "$created_path" ]; then
        validated_path="$created_path"
      else
        echo "‚ùå Nenhum arquivo v√°lido encontrado"
        echo "recovery_status=failed" >> /tmp/file_recovery_context.txt
        return 1
      fi
      
      echo "Arquivo validado: $validated_path"
      
      # Validar arquivo
      validation_checks=0
      validation_passed=0
      
      # Check 1: Arquivo existe
      if [ -f "$validated_path" ]; then
        echo "‚úÖ Check 1: Arquivo existe"
        ((validation_passed++))
      fi
      ((validation_checks++))
      
      # Check 2: Arquivo √© leg√≠vel
      if [ -r "$validated_path" ]; then
        echo "‚úÖ Check 2: Arquivo √© leg√≠vel"
        ((validation_passed++))
      fi
      ((validation_checks++))
      
      # Check 3: Arquivo tem conte√∫do
      if [ -s "$validated_path" ]; then
        echo "‚úÖ Check 3: Arquivo tem conte√∫do"
        ((validation_passed++))
      fi
      ((validation_checks++))
      
      # Check 4: Diret√≥rio pai √© acess√≠vel
      parent_dir=$(dirname "$validated_path")
      if [ -x "$parent_dir" ]; then
        echo "‚úÖ Check 4: Diret√≥rio pai √© acess√≠vel"
        ((validation_passed++))
      fi
      ((validation_checks++))
      
      # Determinar status da recupera√ß√£o
      if [ "$validation_passed" -eq "$validation_checks" ]; then
        echo "‚úÖ Todos os checks de valida√ß√£o passaram"
        recovery_status="success"
      elif [ "$validation_passed" -gt 0 ]; then
        echo "‚ö†Ô∏è Alguns checks falharam, mas arquivo est√° acess√≠vel"
        recovery_status="partial"
      else
        echo "‚ùå Todos os checks de valida√ß√£o falharam"
        recovery_status="failed"
      fi
      
      # Salvar resultados
      echo "validated_path=$validated_path" >> /tmp/file_recovery_context.txt
      echo "validation_checks=$validation_checks" >> /tmp/file_recovery_context.txt
      echo "validation_passed=$validation_passed" >> /tmp/file_recovery_context.txt
      echo "recovery_status=$recovery_status" >> /tmp/file_recovery_context.txt

  - name: "generate_recovery_report"
    run: |
      # Gerar relat√≥rio de recupera√ß√£o
      echo "üìä Gerando relat√≥rio de recupera√ß√£o..."
      
      # Carregar contexto
      source /tmp/file_recovery_context.txt
      
      cat > /tmp/file_recovery_report.txt << EOF
Relat√≥rio de Recupera√ß√£o de Arquivo
===================================

Data: $(date)
Arquivo Original: $file_path
Erro Original: $error_message
Tipo de Erro: $error_type
Estrat√©gia: $search_strategy

Status da Recupera√ß√£o: $recovery_status
Caminho Validado: ${validated_path:-"N/A"}

An√°lise do Problema:
- Arquivo solicitado: $file_path
- Tipo de erro: $error_type
- Causa prov√°vel: $(case $error_type in
  "not_found") echo "Arquivo n√£o existe no caminho especificado";;
  "permission") echo "Permiss√µes de acesso inadequadas";;
  "no_such_file") echo "Arquivo ou diret√≥rio n√£o encontrado";;
  "is_directory") echo "Caminho aponta para diret√≥rio, n√£o arquivo";;
  *) echo "Causa desconhecida";;
esac)

A√ß√µes Executadas:
1. An√°lise do erro e caminho
2. Verifica√ß√£o de exist√™ncia do arquivo
3. Busca em locais alternativos
4. Cria√ß√£o de estrutura ausente (se necess√°rio)
5. Corre√ß√£o de permiss√µes
6. Valida√ß√£o final

Resultados:
- Arquivo existe: ${file_exists:-"false"}
- Arquivo criado: ${file_created:-"false"}
- Permiss√µes corrigidas: ${permissions_fixed:-"false"}
- Valida√ß√£o: $validation_passed/$validation_checks checks passaram

Arquivo Final: ${validated_path:-"N/A"}

EOF
      
      # Adicionar recomenda√ß√µes baseado no status
      case "$recovery_status" in
        "success")
          cat >> /tmp/file_recovery_report.txt << 'EOF'

Recomenda√ß√µes:
‚úÖ Arquivo recuperado com sucesso
‚úÖ Sistema est√° pronto para uso
‚úÖ Nenhuma a√ß√£o adicional necess√°ria

EOF
          ;;
        "partial")
          cat >> /tmp/file_recovery_report.txt << 'EOF'

Recomenda√ß√µes:
‚ö†Ô∏è Arquivo recuperado parcialmente
‚ö†Ô∏è Verifique o conte√∫do do arquivo
‚ö†Ô∏è Pode ser necess√°rio ajustes manuais
‚ö†Ô∏è Monitore o funcionamento do sistema

EOF
          ;;
        "failed")
          cat >> /tmp/file_recovery_report.txt << 'EOF'

Recomenda√ß√µes:
‚ùå Recupera√ß√£o falhou
‚ùå Verifique o caminho do arquivo manualmente
‚ùå Considere restaurar de backup
‚ùå Verifique permiss√µes do sistema

EOF
          ;;
      esac
      
      echo "‚úÖ Relat√≥rio gerado em /tmp/file_recovery_report.txt"

  - name: "show_recovery_summary"
    run: |
      # Mostrar resumo da recupera√ß√£o
      echo "üéØ RESUMO DA RECUPERA√á√ÉO DE ARQUIVO"
      echo "====================================="
      
      # Carregar contexto
      source /tmp/file_recovery_context.txt
      
      # Mostrar informa√ß√µes principais
      echo "Arquivo: $file_path"
      echo "Status: $recovery_status"
      echo "Estrat√©gia: $search_strategy"
      
      if [ -n "$validated_path" ]; then
        echo "Caminho final: $validated_path"
      fi
      
      # Mostrar estat√≠sticas
      echo "Valida√ß√£o: $validation_passed/$validation_checks checks passaram"
      
      # Mostrar pr√≥ximos passos
      echo ""
      echo "üí° Pr√≥ximos passos:"
      echo "1. Verifique o arquivo recuperado: ${validated_path:-$file_path}"
      echo "2. Revise o relat√≥rio completo: /tmp/file_recovery_report.txt"
      echo "3. Teste o funcionamento do sistema"
      echo "4. Monitore por problemas relacionados"
      
      # Status final
      if [ "$recovery_status" = "success" ]; then
        echo ""
        echo "‚úÖ Recupera√ß√£o de arquivo conclu√≠da com sucesso!"
      elif [ "$recovery_status" = "partial" ]; then
        echo ""
        echo "‚ö†Ô∏è Recupera√ß√£o parcial - arquivo acess√≠vel mas pode precisar ajustes"
      else
        echo ""
        echo "‚ùå Recupera√ß√£o falhou - interven√ß√£o manual necess√°ria"
      fi

error_handling:
  - step: "analyze_file_error"
    on_error: "continue"
    message: "Falha na an√°lise do erro, continuando com an√°lise gen√©rica"
  
  - step: "check_file_existence"
    on_error: "continue"
    message: "Falha ao verificar exist√™ncia, assumindo arquivo n√£o existe"
  
  - step: "search_alternative_locations"
    on_error: "continue"
    message: "Falha na busca alternativa, continuando sem alternativas"
  
  - step: "create_missing_structure"
    on_error: "continue"
    message: "Falha ao criar estrutura, tentando continuar"
  
  - step: "fix_permissions"
    on_error: "continue"
    message: "Falha ao corrigir permiss√µes, continuando sem corre√ß√£o"
  
  - step: "validate_recovery"
    on_error: "continue"
    message: "Falha na valida√ß√£o, assumindo recupera√ß√£o parcial"
  
  - step: "generate_recovery_report"
    on_error: "continue"
    message: "Falha ao gerar relat√≥rio, criando resumo simplificado"
  
  - step: "show_recovery_summary"
    on_error: "continue"
    message: "Falha ao mostrar resumo, recupera√ß√£o conclu√≠da silenciosamente"

examples:
  - name: "Recupera√ß√£o de Arquivo de Teste"
    description: "Recuperar arquivo de teste n√£o encontrado"
    command: "killo action file_recovery --file_path='tests/unit/services/cacheService.test.js' --error_message='File not found' --search_strategy=hierarchical --create_if_missing=true"

  - name: "Recupera√ß√£o de Arquivo de Configura√ß√£o"
    description: "Recuperar arquivo de configura√ß√£o ausente"
    command: "killo action file_recovery --file_path='config/database.js' --error_message='no such file' --search_strategy=pattern_matching --create_if_missing=true"

  - name: "Corre√ß√£o de Permiss√µes"
    description: "Corrigir problemas de permiss√£o de arquivo"
    command: "killo action file_recovery --file_path='src/app.js' --error_message='permission denied' --search_strategy=hierarchical --create_if_missing=false"

integration:
  vscode:
    command: "killo.action.file_recovery"
    parameters:
      file_path: "${file}"
      error_message: "--error_message"
      search_strategy: "--search_strategy"
      create_if_missing: "--create_if_missing"
  
  terminal:
    command: "killo action file_recovery"
    parameters:
      file_path: "--file_path"
      error_message: "--error_message"
      search_strategy: "--search_strategy"
      create_if_missing: "--create_if_missing"
      backup_existing: "--backup_existing"

output_formats:
  - name: "detailed"
    description: "Relat√≥rio detalhado completo"
    default: true
  
  - name: "summary"
    description: "Resumo conciso da recupera√ß√£o"
    parameter: "--output=summary"
  
  - name: "json"
    description: "Sa√≠da em JSON para integra√ß√£o"
    parameter: "--output=json"